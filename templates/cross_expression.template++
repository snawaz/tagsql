

#pragma once

__BEGIN_HEADER__

#include <type_traits>
#include <string>
#include <memory>
#include <array>

#include <__NAMESPACE__/table.h++>
#include <__NAMESPACE__/meta_table.h++>
#include <__NAMESPACE__/meta_column.h++>
#include <__NAMESPACE__/tags.h++>
#include <__NAMESPACE__/deferred_range.h++>
#include <__NAMESPACE__/row_type_helper.h++>
#include <pqxx/pqxx>

__END_HEADER__

__BEGIN_NAMESPACE__

template<typename TableList, typename SelectedColumnsTuple>
class cross_expression : public deferred_range<typename detail::row_type<TableList, SelectedColumnsTuple>::type>
{
    	using base = deferred_range<typename detail::row_type<TableList, SelectedColumnsTuple>::type>;
    	using table_type = typename TableList::template at<TableList::size-1>::type;
    public: 
	using value_type = typename base::value_type;
	using implied_select = typename detail::row_type<TableList, SelectedColumnsTuple>::modified_tuple;

	cross_expression(std::shared_ptr<pqxx::connection> & connection, std::string query_without_select)
	    : base(connection), _query_without_select(query_without_select) 
	{
	    _query_without_select += " CROSS JOIN " + metaspace::meta_table<table_type>::name();
	}
	template<typename OtherTable>
	auto cross_join() -> cross_expression<typename TableList::template push_back<OtherTable>::type, SelectedColumnsTuple >
	{
	    return { this->_connection, _query_without_select };
	}
	auto limit(std::size_t count) -> cross_expression<TableList, SelectedColumnsTuple> &
	{
	    _query_without_select += " LIMIT " + std::to_string(count);
	    return *this;
	}
	auto exec() -> std::vector<value_type>
	{
	    return deferred_exec(); 
	}
    protected:
	virtual std::vector<value_type>& deferred_exec()
	{
	    return this->execute(implied_select(), _query_without_select);
	}
    private:
	std::string  _query_without_select;
};

__END_NAMESPACE__
