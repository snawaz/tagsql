

#pragma once

__BEGIN_HEADER__

#include <type_traits>
#include <string>
#include <memory>
#include <array>

#include <__NAMESPACE__/table.h++>
#include <__NAMESPACE__/meta_table.h++>
#include <__NAMESPACE__/meta_column.h++>
#include <__NAMESPACE__/tags.h++>
#include <__NAMESPACE__/deferred_range.h++>
#include <__NAMESPACE__/row_type_helper.h++>
#include <pqxx/pqxx>

__END_HEADER__

__BEGIN_NAMESPACE__ 

enum class sql_join_type
{
    inner,
    left,
    right,
};

template<sql_join_type JoinType, typename TableList, typename SelectedColumnsTuple>
class join_expression : public deferred_range<typename detail::row_type<TableList, SelectedColumnsTuple>::type>
{
    	using base = deferred_range<typename detail::row_type<TableList, SelectedColumnsTuple>::type>;
    	using table_type = typename TableList::template at<TableList::size-1>::type;
    public: 
    	using value_type = typename base::value_type;
    	using implied_select = typename detail::row_type<TableList, SelectedColumnsTuple>::modified_tuple;

	join_expression(std::shared_ptr<pqxx::connection> & connection, std::string query_without_select)
	    : base(connection), _query_without_select(query_without_select) 
	{
	    if ( JoinType == sql_join_type::inner) _query_without_select += " INNER JOIN " + metaspace::meta_table<table_type>::name();
	    else if ( JoinType == sql_join_type::left) _query_without_select += " LEFT JOIN " + metaspace::meta_table<table_type>::name();
	    else if ( JoinType == sql_join_type::right) _query_without_select += " RIGHT JOIN " + metaspace::meta_table<table_type>::name();
	}
	template<typename OtherTable>
	auto join() -> join_expression<sql_join_type::inner, typename TableList::template push_back<OtherTable>::type , SelectedColumnsTuple>
	{
	    return {this->_connection};
	}
	auto on(condition clause) 
	{
	    _query_without_select += " ON " + clause._value;
	    return *this;
	}
	auto limit(std::size_t count)
	{
	    _query_without_select += " LIMIT " + std::to_string(count);
	    return *this;
	}
	auto exec() -> std::vector<value_type>
	{
	    return deferred_exec(); 
	}
    protected:
	virtual std::vector<value_type>& deferred_exec()
	{
	    return this->execute(implied_select(), _query_without_select);
	}
    private:
	std::string                       _query_without_select;
};

__END_NAMESPACE__
